<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>log4j日志</title>
      <link href="/2020/04/22/log4j%E6%97%A5%E5%BF%97/"/>
      <url>/2020/04/22/log4j%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>在工作过程中，编码是构建一个项目的开始，而日志记录则是维护一个项目的基石。如果一个项目中，没有完善的日志记录，那么这个项目则会有以下缺陷：  </p><ol><li>项目没有报错检测机制</li><li>项目出现系统错误时无法查找问题</li></ol><p>现有的一些系统监测平台，都是通过获取项目的日志来进行错误报警，提示开发人员及时解决系统存在的问题。如果出现问题，需要通过记录下来的日志来记录错误信息以及上下文信息，这样可以有效及时的锁定错误。</p><p>因此，日志记录对一个项目来说是非常重要的。</p><p>我在工作过程中，也时刻想着如何记录日志，才能快速定位问题。在实践过程中，我使用三层的日志记录：  </p><ol><li>Controller层使用拦截器，拦截所有用户操作请求，记录用户行为和参数。这个通常是为了审计需要记录的审计日志。</li><li>Service层使用Spring AOP功能对所有方法进行切片日志记录。主要是三个切面，方法进入前、进入后、报错时，分别记录方法的参数、返回结果和错误信息。</li><li>针对每处业务处理代码中，记录错误或者报警日志。这些日志常常为正常业务处理中遇到的可预知的错误，比如方法的参数不正确，用户的信息未找到等信息。</li></ol><p>通过这三层日志，可以全方位的记录用户在使用平台的过程中，操作的什么内容，输入了什么信息，查询到了什么结果，如果发生异常情况，异常信息是什么，在哪里发生的等等。。。</p><p>我们都知道日志一般不能只打印到工作台中，还需要记录到日志文件中，那么应该如何在工具层面把日志记录下来呢。这是本篇的重点。</p><p>正文之前，先说下这片博文的起源。我在系统开发过程中，遇到了一个很奇怪的问题。系统在测试环境中，为了方面测试功能数据权限，我们加了一个切换session的功能。这样可以方便测试人员，切换不能角色来看数据权限和功能权限。但是呢，在切换的过程中，发现人员的数据权限不正确，跟预想的不同。排除了代码bug的情况下，思考可能是session切换有问题，但是通过查询日志发现，session确实切到了正确的人，那为什么查询结果不正确呢。我请教了我的导师，我的导师建议我去查一下mybatis执行sql日志。但是怎么才能输出mybatis执行的sql日志呢？下面就是正文了。</p><p>以log4j为例，我们需要记录系统中不同模块日志到不同的文件中。那么日志的配置应该是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">xmlns:log4j</span>=<span class="string">"http://jakarta.apache.org/log4j/"</span> <span class="attr">debug</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 全局配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">priority</span> <span class="attr">value</span>=<span class="string">"INFO"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"Console"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"saLog"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"DEBUG"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"saLogAppender"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"saLogAppender"</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.DailyRollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"File"</span> <span class="attr">value</span>=<span class="string">"/home/xiaoju/soc-logs/soc-web/soc-web-sa.log"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"DatePattern"</span> <span class="attr">value</span>=<span class="string">"'.'yyyy-MM-dd"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ConversionPattern"</span> <span class="attr">value</span>=<span class="string">"[%p] %d&#123;yyyy-MM-dd HH:mm:ss&#125; %C.%M : %m%n%x"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是基础的log4j配置。在以前我只知道这么用，但是没有想过这么配的原理是什么。不知道原理的话，在遇到新的问题时就会不知所措，就像现在我想知道如何打印mybatis的执行日志到日志文件中。</p><p>先说这个问题的答案吧，有两种方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">priority</span> <span class="attr">value</span>=<span class="string">"DEBUG"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"Console"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.apache.ibatis"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"DEBUG"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"java.sql.Connection"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"DEBUG"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"java.sql.Statement"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"DEBUG"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"java.sql.PreparedStatement"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"DEBUG"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样项目中所有的mybatis执行sql都会被打印出来，但是这种方式必须要求rootLogger的level是debug。至于为什么需要debug，我也不知道，网上也找不到答案。</p><p>另外一种是更有针对性的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.didichuxing.dao.sa.AssessmentMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"DEBUG"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样只要这个Mapper执行，就会把sql打印出来。</p><p>那么为什么可以这样配置呢？从上面的logger name其实我们能看出来，这个其实就是类名或者包名。所以log4j的日志配置是可以根据类名或者包名来进行定位的，如果一个类打印了日志，那么可以从配置中找其对应的类或者包配置，然后再根据appender将日志信息记录到工作台或者文件中。当然我们也可以单独定义logger name，然后使用这个logger来进行日志打印。</p><p>除此之外，logger是有继承关系的。继承的原理就是根据name来排出上下级。比如一个<code>com.hello.HelloWorld</code>的类打印日志，那么首先会寻找有没有名称为<code>com.hello.HelloWorld</code>的logger配置，如果没有则会找<code>com.hello</code>的logger配置，然后找<code>com</code>的logger配置，最后达到rootLogger。所以日志打印会根据这个继承链从下往上传递日志信息。但是我们不想重复打印这么多次怎么办，使用<code>additivity</code>，设置为<code>false</code>就不会把日志向上传递了。</p><p>另外一个需要注意的是日志的打印等级。log4j一共有OFF、FATAL、ERROR、WARN、INFO、DEBUG、TRACE、ALL 8种，等级依次降低。logger设置了等级之后，则只会记录高于这个等级的日志。如果logger设置为INFO等级，那么所有DEBUG、TRACE、ALL的日志都不会记录。</p><p>从这次不知道怎么打印mybatis的执行sql，学到了怎么设置打印sql，logger设置的原理是什么，日志分发的机制是什么，日志级别的作用，以及logger的继承关系。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-04-20 学习</title>
      <link href="/2020/04/20/2020-04-20-%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/04/20/2020-04-20-%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-面向对象"><a href="#0x01-面向对象" class="headerlink" title="0x01 面向对象"></a>0x01 面向对象</h2><p>在日常开发过程中，我们经常会使用写一些面向过程的代码，比较显著的例子是全局变量和全局方法。全局变量是将所有的静态成员变量或者常量放在一个类中，这样做不要的地方是，破坏了封装特性。  </p><p>一个Constants类中可能会有大量的静态变量或者常量，其他类或者模块使用这个类时，需要不断对这个文件进行编译，费时费力。因此，我们应该尽量避免大Constants类的存在。可以将大Constants类按照功能分为小的文件，也可以根据模块作用域、类作用域进行划分。</p><p>另一个常见的例子是Utils类。Utils类只保留方法，不包括数据，所以也是面向过程的思想。那我们如何按照面向对象的思路进行设计呢？首先需要思考一下为什么需要Utils类？为的是提高代码复用性，可能几个类使用到了相同的数据处理逻辑，所以把相同的代码提取出来作为Utils类。那么既然是这样的话，我们为什么不使用继承特性呢，把重复代码放在父类中。当然并不是所有情况都适合抽象成父类，需要视情况而定。</p><h2 id="0x02-基于接口而非实现编程"><a href="#0x02-基于接口而非实现编程" class="headerlink" title="0x02 基于接口而非实现编程"></a>0x02 基于接口而非实现编程</h2><p>一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总要习惯一个人</title>
      <link href="/2019/10/06/%E6%80%BB%E8%A6%81%E4%B9%A0%E6%83%AF%E4%B8%80%E4%B8%AA%E4%BA%BA/"/>
      <url>/2019/10/06/%E6%80%BB%E8%A6%81%E4%B9%A0%E6%83%AF%E4%B8%80%E4%B8%AA%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;标题不是表示我现在的处境或者想法，而是一本书的名字，《总要习惯一个人》。这本书是我在逛西西弗书店的时候偶然看到的，因为书名就扫了一眼内容，然后就买了下来。书的作者是蕊希，说实话不太知道这个作者是谁，看简介是一位同龄电台主持人、90后CEO，曾经在广电工作过，一看就是一个很厉害的姑娘。于是就看了一下这本书。</p><p>&emsp;&emsp;这本书的主要内容是作者平时生活中的一些感想感悟，算是平时所思所想的整合。文章大多涉及了爱情观、价值观、生活观，有很多观点我还是比较认同的。所以记录一下这本书的读后感想。</p><p>&emsp;&emsp;作者在刚开始介绍了本人的一些情感经历以及在经历后的一些思考。从她的文章中可以看出，两个人能够在一起，不关乎金钱、不关乎长相、不关乎年龄，只关乎于三观是否相同、关乎灵魂是否契合。灵魂契合这是一个很玄幻的表达，通俗地说就是两个人是否能聊到一起、生活到一起。一个人吸引另外一个人主要是靠什么，魅力！什么是魅力，长得好看？身材好？这是一方面。都说现在这个时代是一个看脸的时代，不可否认。我们择偶首先看的就是长相、身材。但这只能确定两个人是否愿意在一起，而在一起多长时间、在一个如何相处取决于另外的因素。</p><p>&emsp;&emsp;这时又要祭出那句很经典的话了，<code>好看的皮囊千篇一律，有趣的灵魂万里挑一</code>。灵魂有不有趣不重要，重要的是这个灵魂是不是你的菜。一个人的魅力不仅仅是靠外貌，还有气质、谈吐、性格等等。这个时代看脸，但是这个时代里的人不仅仅看脸或者说有不看脸的人，也看内在。两个人在一起是为了什么，就是为了看着舒服？或者领出去有面？是的，看着舒服领出去是有面，但是其中滋味只有自己知道。我很信奉<code>宁缺毋滥</code>这个想法，当然爱情里不是<code>滥</code>，而适不适合、喜不喜欢。对于不适合、不喜欢的人，坚决不将就。这是一种恋爱中的态度。书中有句话我很认同，<code>“我们都在等世上唯一契合灵魂”</code>，不同的是，有些人已经等到，而有些人还在“等待中”。</p><p>&emsp;&emsp;书中有一段我认为写得非常好的话，在这分享出来：</p><pre><code>如果你有能力和财力，那就能走多远走多远，去远方，现在就上路。  如果你暂时还没有出发的条件，那就去读诗，因为诗里就有你要的远方，然后，努力，早日上路。我期待着我的人生是这样的：不为金钱和传统的财力观念所累，不为别人的期许和要求而活。不固步自封在眼下的这方狭小的天地，也不沉溺于此刻的得失与人生的起落。找一个愿意并且能够和我生活的人，居有定所，却也浪迹天涯。</code></pre><p>&emsp;&emsp;这段话很文艺范，但是真的就是我想要的生活。有句老话叫，<code>读万卷书，行万里路</code>。我直到最近才明白这句话是什么含义。高晓松的妈妈告诉他一句话，<code>生活不只眼前的苟且，还有诗和远方</code>。这两句话是一个意思，说给别人听，别人肯定会认为你在装逼、在打鸡血。书和路、诗和远方，代表了我们认识世界、接触外界的两种方式。一种是通过读别人的故事，一种是自己去经历。当我们没有能力去行万里路、去经历的时候，我们就应该在书中去了解外面的世界。当我们有能力出去走走，不要犹豫，出去看看大好河川、人文景观。我们的一生，寥寥几十载，如何度过是一个很大的话题。不固步自封在眼下的狭小天地，是我们灿烂人生的第一步。外面有世界有太多太多精彩的瞬间，我们应该去经历、去认识。当然如果有个人愿意陪着一起，那也是极好的。写到这突然想起了《北京青年》这部剧，里面的大哥也是这么想的吧。</p><p>&emsp;&emsp;书中最后写了作者父母在这些年对作者在事业上、生活上、感情上的一起教导，让我不禁感概，果然什么样的父母就有什么样的子女。在一个孩子的教育上，家长父母的影响绝对是一生的。父母言传身教决定了孩子会生长为一个什么样的人。以我为例，我的父母是普通的农民，没有受过太多的教育，只是中学毕业。父母不会对我讲很多大道理，但是平时的待人处事之道对我的影响很大。父母平时怎么做，还是就会怎么学。所以作者会这么优秀，父母的教育应该起到了很大的作用。</p><p>&emsp;&emsp;这本书，怎么说呢，里面的很多观念都与我很契合，也是很正的。很多事情的叙述都是以女性的角度展开的，推荐女生看看。一个女孩子能在这个年龄、这个环境下，取得这么大的成绩还是值得学习的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 线程池（生命周期管理）</title>
      <link href="/2019/09/27/Spring-%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%EF%BC%89/"/>
      <url>/2019/09/27/Spring-%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-Spring-Bean生命周期管理"><a href="#0x01-Spring-Bean生命周期管理" class="headerlink" title="0x01 Spring Bean生命周期管理"></a>0x01 Spring Bean生命周期管理</h2><p>Spring在管理Bean时除了<strong>依赖注入</strong>这一主要功能外，也提供了在项目启动初始化Bean和项目结束销毁Bean时的附加功能，这一功能对某些涉及到资源管理的Bean来说很有用，也就是本文要说的线程池。</p><p>Spring在初始化Bean之后和销毁Bean之前提供了进行一些自定义操作的入口，主要有一下几种方式：   </p><blockquote><p>1、注解方式，在方法上使用<code>@PostConstruct</code>和<code>@PreDestroy</code>注解</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化方法</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after init ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁方法</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before destroy ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2、注解方式，在<code>@Bean</code>指定Bean的同时通过注解的属性<code>initMethod</code>和<code>destroyMethod</code>指定</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @Bean</span></span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>, destroyMethod = <span class="string">"destroy"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DemoService <span class="title">demoService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3、xml配置，通过<code>&lt;bean&gt;</code>的<code>init-method</code>和<code>destroy-method</code>属性指定</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"haocdp.spring.core.DemoService"</span> <span class="attr">init-method</span> = <span class="string">"init"</span> <span class="attr">destroy-method</span> = <span class="string">"destroy"</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>4、通过实现<code>InitializingBean</code>和<code>DisposableBean</code>接口实现初始化和销毁相关操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitOrderBean</span>   <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"after ..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"before ..."</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是第二种方式和第三种方式是同一种配置的不同实现方式，并与其他两种方式有所差异。</p><p>如果这几种方式同时存在，执行顺序如下：</p><p><strong>实例化： Constructor -&gt; @PostConstruct -&gt; InitializingBean -&gt; init-method</strong></p><hr><p><strong>销毁：   @PreDestroy -&gt; DisposableBean -&gt; destroy-method</strong></p><hr><p>这样顺序的具体原因与Spring Bean生命周期相关，本文就不做详细探讨，我也没有详细了解过。只需要知道这几种方式只是Spring提供的一些功能，方便进行一些附加操作。</p><h2 id="0x02-线程池生命周期"><a href="#0x02-线程池生命周期" class="headerlink" title="0x02 线程池生命周期"></a>0x02 线程池生命周期</h2><p>之所以会关注到Spring Bean的生命周期问题，是因为在使用线程池时涉及到了线程池如何优雅关闭的问题，查看Spring线程池的源码时，看到了下面这部分代码：<br>￼￼<img src="../../../../images/20190927/1.png" alt="avatar"><br>这是Spring线程池的一个抽象父类代码，可以看到该类实现了上述的<code>InitializingBean</code>和<code>DisposableBean</code>接口，也就是说Spring管理线程池的生命周期是通过这种方式实现的。</p><p>对线程池比较熟悉的同学应该都知道线程池的基本配置和运行方式，这里不做详述。本文关注的是线程池的生命周期。线程池的状态一共有running、shutdown、stop、tidying和terminated。   </p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>Running</td><td>能接受提交新任务，也能处理阻塞队列中的任务</td></tr><tr><td>Shutdown</td><td>不能接受提交的新任务，但是能处理阻塞队列中的未完任务</td></tr><tr><td>Stop</td><td>不能接受新任务，也不能处理阻塞队列中的任务，并且会中断正在处理任务的线程</td></tr><tr><td>Tidying</td><td>如果所有的任务都终止了，有效线程数为0，会进入该状态</td></tr><tr><td>Terminated</td><td>工作线程数为0，工作队列任务数为0，由tidying状态进入，线程池彻底结束</td></tr></tbody></table><p><strong>线程池状态之间的转换关系如下：</strong> </p><table><thead><tr><th>状态转换</th><th>说明</th></tr></thead><tbody><tr><td>Running -&gt; Shutdown</td><td>调用线程池的<code>shutdown()</code>方法</td></tr><tr><td>Running/Shutdown -&gt; Stop</td><td>调用线程池的<code>shutdownNow()</code>方法</td></tr><tr><td>Shutdown -&gt; Tidying</td><td>阻塞队列为空，线程池工作线程数为0</td></tr><tr><td>Stop -&gt; Tidying</td><td>线程池中工作线程数为0</td></tr><tr><td>Tidying -&gt; Terminated</td><td>执行terminated()方法进入</td></tr></tbody></table><p>从上述可以看出，Running状态下通过调用<code>shutdown()</code>/<code>shutdownNow()</code>进行状态转换，这是程序手动执行的，而Tidying状态是为了整理工作线程和阻塞队列，所以只要条件达到就会进入该状态。虽然进入Terminated状态需要调用<code>terminated()</code>方法，但是这是一个钩子方法，只要进入Tidying就会执行。</p><h2 id="0x03-Spring-管理线程池"><a href="#0x03-Spring-管理线程池" class="headerlink" title="0x03 Spring 管理线程池"></a>0x03 Spring 管理线程池</h2><p>这里我们重点关注shutdown()和shutdownNow()方法，因为在工作过程中，调用不同的方法会造成不同的结果。先说一下工作中遇到的问题。<br>工作中经常会做一些耗时比较长的操作，比如发送邮件或者记录操作日志，这些操作通常是正常业务逻辑触发的一些附加功能。如果同步执行会造成正常操作反应时间过长的问题。所以需要另开线程进行操作。这时需要使用线程池。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"targetExecutor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"corePoolSize"</span> <span class="attr">value</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"queueCapacity"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>定义线程池，并在代码中执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">targetExecutor.execute(() -&gt; addOperateLog(beforeEventInfo, eventInfo));</span><br></pre></td></tr></table></figure><p>在正常的部署项目中，执行代码没有任何问题，任务提交到线程池中进行执行。但是在单元测试中执行就会有问题了。线程池的任务没有正常执行完毕。<br>通过分析正常部署项目和单元测试的差异，我们可以知道，正常部署项目中线程池的生命周期贯穿整个项目，只有服务停掉才会销毁线程池。但是单元测试主线程执行完就会关闭线程池，从而导致任务没有正常执行完毕。<br>这里涉及到了Spring Bean的生命周期管理。线程池的生命周期就是通过上述说到的自定义初始化和销毁操作进行管理。<br>查看线程池的代码：<br>￼￼<img src="../../../../images/20190927/2.png" alt="avatar"><br>￼￼<img src="../../../../images/20190927/1.png" alt="avatar"><br>可以看到线程池实现了InitializingBean和DisposableBean接口，因此当Spring容器关闭时就会调用destroy()方法<br>￼￼<img src="../../../../images/20190927/3.png" alt="avatar"><br>重点在shutdown方法中<br>￼￼<img src="../../../../images/20190927/4.png" alt="avatar"><br>通过查看这里的源码可以得知，调用<code>shutdown()</code>还是<code>shutdownNow()</code>方法取决于<code>waitForTasksToCompleteOnShutdown</code>参数。所以，如果改一下线程池的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"targetExecutor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"corePoolSize"</span> <span class="attr">value</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"queueCapacity"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"waitForTasksToCompleteOnShutdown"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"awaitTerminationSeconds"</span> <span class="attr">value</span>=<span class="string">"60"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么线程池从Running状态会进入Shutdown，这是会等待已有的任务执行完毕再关闭线程池。单元测试就会正常执行了。<br>其中还有一个<code>awaitTerminationSeconds</code>参数是指等待线程池状态到Terminated的最长时间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring MVC </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC 一次请求完整过程</title>
      <link href="/2019/09/18/Spring-MVC-%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/09/18/Spring-MVC-%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>一次请求的完整顺序：    </p><table><thead><tr><th align="left">调用顺序</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Filter -&gt;</td><td align="left">用户自定义过滤器</td></tr><tr><td align="left">DispatcherServlet -&gt;</td><td align="left">调度中心</td></tr><tr><td align="left">HandlerMapping -&gt;</td><td align="left">处理请求映射</td></tr><tr><td align="left">getHandler -&gt;</td><td align="left">得到请求对应的处理方法</td></tr><tr><td align="left">getHandlerAdapter -&gt;</td><td align="left">得到调用处理方法的适配器</td></tr><tr><td align="left">Interceptor.preHandle -&gt;</td><td align="left">拦截器前处理</td></tr><tr><td align="left">handlerAdapter.handle -&gt;</td><td align="left">调用适配器方法</td></tr><tr><td align="left">HandlerMethod.invoke -&gt;</td><td align="left">调用请求对应的用户定义方法</td></tr><tr><td align="left">Interceptor.postHandle -&gt;</td><td align="left">拦截器后处理</td></tr><tr><td align="left">Interceptor.afterCompletion -&gt;</td><td align="left">拦截器完成处理</td></tr><tr><td align="left">Filter</td><td align="left">回到用户自定义过滤器</td></tr></tbody></table><p><img src="../../../../images/20190918/1-LoginFilter.png" alt="avatar"></p><p><img src="../../../../images/20190918/2-LoginFilter.png" alt="avatar"></p><blockquote><p>用户请求首先进入过滤器中，根据过滤链<code>FilterChain</code>定义进行顺序执行。</p></blockquote><p><img src="../../../../images/20190918/3-DispatcherServlet.png" alt="avatar"></p><blockquote><p>请求通过过滤链之后就会进入<code>DispatcherServlet</code>调度中心的<code>doService</code>方法，这也是常规<code>Servlet</code>的调度流程。</p></blockquote><p><img src="../../../../images/20190918/4-DispatcherServlet.png" alt="avatar"></p><p><img src="../../../../images/20190918/5-DispatcherServlet.png" alt="avatar"></p><blockquote><p>在<code>doService</code>中调用<code>doDispatch</code>方法。</p></blockquote><p><img src="../../../../images/20190918/6-DispatcherServlet-doDispatch.png" alt="avatar"></p><blockquote><p>在<code>getHandler</code>方法中获取到URL到处理方法的映射关系，并根据请求获取对应的处理方法。这里获取到的并不仅仅是用户定义的<code>Controller</code>处理方法，还包括拦截器，因此返回得到的是<code>HandlerExecutionChain</code>执行链。</p></blockquote><p><img src="../../../../images/20190918/7-DispatcherServlet-doDispatch.png" alt="avatar"></p><blockquote><p>根据当前的<code>Handler</code>获取对应的执行适配器。</p><blockquote><p>这里需要说明的是由于Web请求可能会有很多种类型，比如数据请求和静态资源请求，也会有很多种实现方式，比如使用注解的<code>@Controller</code>、实现<code>Controller</code>接口和实现<code>Servlet</code>接口，所以<code>Spring MVC</code>为了应对不同类型的请求，定义了<code>Adapter</code>这一角色，主要是为了根据请求的不同类型使用不同的方法处理请求。这里<code>getHandlerAdapter</code>就是为了获取到请求对应的处理适配器。<br><code>Spring MVC</code>中适配器的类型主要分为以下几种：<br><code>AnnotationMethodHandlerAdapter</code>: 适配注解类处理器，即使用<code>@Controller</code>的处理器<br><code>HttpRequestHandlerAdapter</code>: 适配静态资源处理器，静态资源处理器是实现 <code>HttpRequestHandler</code>接口的处理器，这类处理器的作用是处理通过<code>Spring MVC</code>访问静态资源的请求。<br><code>SimpleControllerHandlerAdapter</code>: 适配实现了Controller接口或Controller接口子类的处理器，比如MultiActionController。<br><code>SimpleServletHandlerAdapter</code>: 适配实现了Servlet接口或Servlet的子类的处理器。<br>需要注意的是适配器是可以通过配置文件进行配置的，如果没有配置DispatcherServlet会读取DispatcherServlet.properties进行默认配置，默认的适配器只有前三种，没有<code>SimpleServletHandlerAdapter</code>。</p></blockquote></blockquote><p><img src="../../../../images/20190918/8-DispatcherServlet-doDispatch.png" alt="avatar"></p><p><img src="../../../../images/20190918/9-HandlerExecutionChain-applyPreHandle.png" alt="avatar"></p><blockquote><p>获取到适配器后，开始执行调用链中的拦截器<code>preHandle</code>方法。</p></blockquote><p><img src="../../../../images/20190918/10-DispatcherServlet-doDispatch.png" alt="avatar"></p><blockquote><p>执行完拦截器后才会使用适配器执行用户自定义的请求处理方法。</p></blockquote><p><img src="../../../../images/20190918/11-AbstractHandlerMethodAdapter-handle.png" alt="avatar"></p><blockquote><p>调用<code>AbstractHandlerMethodAdapter</code>的<code>handle</code>方法。</p></blockquote><p><img src="../../../../images/20190918/12-RequestMappingHandlerAdapter-handleInternal.png" alt="avatar"></p><blockquote><p>调用<code>RequestMappingHandlerAdapter</code>的<code>handleInternal</code>方法。</p></blockquote><p><img src="../../../../images/20190918/13-RequestMappingHandlerAdapter-invokeHandlerMethod.png" alt="avatar"></p><p><img src="../../../../images/20190918/14-RequestMappingHandlerAdapter-invokeHandlerMethod.png" alt="avatar"></p><blockquote><p>调用<code>RequestMappingHandlerAdapter</code>的<code>invokeHandlerMethod</code>方法。</p></blockquote><p><img src="../../../../images/20190918/15-ServletInvocableHandlerMethod-invokeAndHandle.png" alt="avatar"></p><blockquote><p>调用<code>ServletInvocableHandlerMethod</code>的<code>invokeAndHandle</code>方法。</p></blockquote><p><img src="../../../../images/20190918/16-InvocableHandlerMethod-invokeForRequest.png" alt="avatar"></p><p><img src="../../../../images/20190918/17-InvocableHandlerMethod-invokeForRequest.png" alt="avatar"></p><blockquote><p>调用<code>InvocableHandlerMethod</code>的<code>invokeForRequest</code>方法。</p></blockquote><p><img src="../../../../images/20190918/18-InvocableHandlerMethod-doInvoke.png" alt="avatar"></p><blockquote><p>调用<code>InvocableHandlerMethod</code>的<code>doInvoke</code>方法。</p></blockquote><p><img src="../../../../images/20190918/19-realMethod.png" alt="avatar"></p><blockquote><p>（最重要的来了）进入到用户定义的请求处理方法。</p></blockquote><p><img src="../../../../images/20190918/20-DispatcherServlet-doDispatch.png" alt="avatar"></p><p><img src="../../../../images/20190918/21-HandlerExecutionChain-applyPostHandle.png" alt="avatar"></p><blockquote><p>得到请求结果后，执行拦截器的<code>postHandle</code>方法。</p></blockquote><p><img src="../../../../images/20190918/22-DispatcherServlet-processDispatchResult.png" alt="avatar"></p><p><img src="../../../../images/20190918/23-HandlerExecutionChain-triggerAfterCompletion.png" alt="avatar"></p><blockquote><p>最后执行拦截器的<code>afterCompletion</code>方法。</p></blockquote><p><img src="../../../../images/20190918/24-LoginFilter.png" alt="avatar"></p><blockquote><p>最后执行完回到过滤器。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC项目初始化</title>
      <link href="/2019/09/18/Spring-MVC%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2019/09/18/Spring-MVC%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>我们都知道启动一个<code>Spring MVC</code>项目，需要类似<code>Tomcat</code>的容器支持。<code>Tomcat</code>是一种<code>Servlet</code>容器用于启动<code>Java web</code>项目，而启动一个项目的入口就是<code>web.xml</code>配置文件。在<code>web.xml</code>中主要是为了配置项目中使用的<code>Servlet</code>、<code>Filter</code>和<code>Listener</code>，并对这几种角色进行初始化。这几种角色的作用就不多说了。本文的重点放在项目启动过程，也就是项目初始化。</p><h2 id="0x02-web-xml配置文件"><a href="#0x02-web-xml配置文件" class="headerlink" title="0x02 web.xml配置文件"></a>0x02 web.xml配置文件</h2><p>针对一个<code>Spring MVC</code>项目，需要在<code>web.xml</code>中加载<code>Spring</code>配置文件。初始化的方式有两种：</p><blockquote><p>第一种，使用<code>Listener</code>进行初始化</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:mybatis.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>第二种，使用<code>DispatcherServlet</code>进行初始化</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-web.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于第一种方式，使用<code>ContextLoaderListener</code>监听<code>ServletContext</code>初始化时执行，根据<code>context-param</code>的值读取<code>Spring</code>配置文件进行初始化。关于为什么可以使用<code>Listener</code>进行初始化，可以参考<a href="https://haocdp.github.io/2019/09/06/Java-Web-Listener" target="_blank">Java Web Listener</a>这篇文章。这种方式初始化得到的是<code>Application Context</code>。<br>而第二种方式，是<code>Spring MVC</code>项目更为常见的，因为<code>Spring MVC</code>项目都需要使用<code>DispatcherServlet</code>分发请求。通过<code>init-param</code>加载配置文件进行初始化。这种方式得到的上下文是<code>WebApplicationContext</code>，它是<code>ApplicationContext</code>的子上下文环境。</p><h2 id="0x03-初始化过程"><a href="#0x03-初始化过程" class="headerlink" title="0x03 初始化过程"></a>0x03 初始化过程</h2><p>本文同时使用两种加载配置方式进行初始化，从源代码的层面熟悉整个初始化过程。当然，以我目前的水平只能大致了解一下初始化过程，里面很多详细的过程还没有深究。  </p><p><img src="../../../../images/20190918/init-1.png" alt="avatar"> </p><p><img src="../../../../images/20190918/init-2.png" alt="avatar"> </p><p><img src="../../../../images/20190918/init-3.png" alt="avatar"> </p><p>前面的大致过程是初始化上下文信息，生成<code>ApplicationContext</code>。<br><img src="../../../../images/20190918/init-4.png" alt="avatar"> </p><p>最后来到<code>refresh</code>方法，这里才是初始化重要的位置。顺序来说就是根据配置文件的位置读取到配置文件生成资源文件，然后对这个资源文件进行解析生成<code>BeanFactory</code>。<code>BeanFactory</code>就是对Bean进行管理的地方。默认<code>Bean</code>的<code>Scope</code>都是<code>Singleton</code>，所以初始化得到的都是单例。</p><p>初始化<code>ApplicationContext</code>之后，web容器便会对Filter进行初始化，初始化的过程是调用<code>init</code>方法。最后才是<code>Servlet</code>,同样是调用<code>init</code>方法。（初始化顺序：Listener -&gt; Filter -&gt; Servlet) 所以初始化Filter完成之后，便会对<code>DispatcherServlet</code>进行初始化。由于<code>DispatcherServlet</code>本身并没有<code>init</code>方法，所以会调用父类<code>HttpServletBean</code>的方法。<code>DispatcherServlet</code>是一个多层继承的子类，<code>HttpServletBean</code>不是直接父类。</p><p><img src="../../../../images/20190918/init-5.png" alt="avatar"> </p><p>然后会调用<code>FrameworkServlet</code>的<code>initServletBean</code>方法。</p><p><img src="../../../../images/20190918/init-6.png" alt="avatar"> </p><p>在<code>initServletBean</code>方法中调用<code>initWebApplicationContext</code>方法，从这里开始的初始化过程与上述基本相同，都是读取配置文件生成上下文环境和对应的<code>BeanFactory</code>。</p><p>在加载配置文件的过程中有两个核心类：<br><code>DefaultListableBeanFactory</code> 和 <code>XmlBeanDefinitionReader</code>。</p><h2 id="0x04-Spring配置文件读取"><a href="#0x04-Spring配置文件读取" class="headerlink" title="0x04 Spring配置文件读取"></a>0x04 Spring配置文件读取</h2><p><strong>DefaultListableBeanFactory：Bean加载的核心部分，是多个功能的结合。</strong> </p><hr><p>1、AliasRegistry：定义对alias的简单增删改操作<br>2、SingletonBeanRegistry：定义对单例的注册和获取<br>3、BeanFactory：定义获取bean及其属性<br>4、BeanDefinitionRegistry：定义对BeanDefinition的各种增删改操作<br>5、ConfigurableBeanFactory：提供配置Factory的各种方法<br>6、ListableBeanFactory：根据各种条件获取bean的配置清单<br>7、AutowireCapableBeanFactory：提供创建bean、自动注入、初始化以及应用bean的后处理器<br>DefaultListableBeanFactory是结合上面所有接口功能的实现类，其中也有针对不同功能也有不同的实现类。</p><p><strong>XmlBeanDefinitionReader:针对XML配置文件的读取</strong>  </p><hr><p>1、ResourceLoader：定义资源加载器，主要应用于根据给定的资源文件地址返回对应的Resource<br>2、BeanDefinitionReader：主要定义资源文件读取并转换为BeanDefinition的各个功能<br>3、EnvironmentCapable：定义获取Environment方法<br>4、DocumentLoader：定义从资源文件加载转换为Document的功能<br>5、BeanDefinitionDocumentReader：定义读取Document并注册BeanDefinition功能<br>6、BeanDefinitionParserDelegate：定义解析Element的各种方法  </p><p> <strong>XML配置文件的读取过程：</strong>  </p><hr><p>1、通过实现EnvironmentCapable和BeanDefinitionReader中的方法，使用ResourceLoader将资源文件路径转换为对应的Resource文件<br>2、通过DocumentLoader对Resource文件进行转换，将Resource文件转换为Document文件<br>3、通过实现接口BeanDefinitionDocumentReader的DefaultBeanDefinitionDocumentReader类对Document进行解析，并使用BeanDefinitionParserDelegate对Element进行解析  </p><p>总的来说，这两个核心类，一个是根据配置文件进行解析功能实现，另一个是根据得到的解析结果进行bean的加载、配置、管理功能实现。两个类都是在层层接口定义的基础上，结合不同组件的功能，共同实现最后的目的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你是人间的四月天</title>
      <link href="/2019/09/08/%E4%BD%A0%E6%98%AF%E4%BA%BA%E9%97%B4%E7%9A%84%E5%9B%9B%E6%9C%88%E5%A4%A9/"/>
      <url>/2019/09/08/%E4%BD%A0%E6%98%AF%E4%BA%BA%E9%97%B4%E7%9A%84%E5%9B%9B%E6%9C%88%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<center>我说你是人间的四月天；</center><center>笑响点亮了四面风；轻灵</center><center>在春的光艳中交舞着变。</center><center>&nbsp;</center><center>你是四月早天里的云烟，</center><center>黄昏吹着风的软，星子在</center><center>&nbsp;&nbsp;&nbsp;无意中闪，细雨点洒在花前。</center><center>&nbsp; </center><center>&nbsp;&nbsp;那轻，那娉婷，你是，鲜妍</center><center>百花的冠冕你戴着，你是</center><center>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;天真，庄严，你是夜夜的月圆。</center><center>&nbsp; </center><center>&nbsp;&nbsp;&nbsp;雪化后那片鹅黄，你像；新鲜</center><center>&nbsp;&nbsp;&nbsp;初放芽的绿，你是；柔嫩喜悦</center><center>&nbsp;&nbsp;&nbsp;水光浮动着你梦期待中白莲。</center><center>&nbsp; </center><center>&nbsp;你是一树一树的花开，是燕</center><center>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在梁间呢喃，——你是爱，是暖，</center><center>&nbsp;&nbsp;&nbsp;是希望，你是人间的四月天！</center><center>&nbsp; </center><p>&nbsp;&nbsp;&nbsp;《你是人间的四月天》是林徽因的一本书，也是一首诗。当时买这本书存粹是买书凑单满减，觉得这本书的名字好熟悉，作者又是林徽因就买下了。说实话，我不是一个合格的文艺青年，完全看不了这本书中的散文和诗歌。也就看看里面的书信，但是呢，书信在完全不了解当时的写信缘由和当下情形的情况下，真的很难看懂是什么意思。不是很了解林徽因、梁思成、胡适、徐志摩，无法理解当时作者的写作缘由和心情。所以，只着重看了书中的这首诗。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;这首诗的名字是《你是人间的四月天》，让我想到了一个动漫，《四月是你的谎言》。这个动漫当时看的感觉就是画面很唯美，剧情很清新、纯爱。剧中有句台词是，“没有你的四月又到了”，给我的印象最深，以至于每到四月份都会想到这部动漫。四月真的是春天最好的季节！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;再说回为什么抄录这首诗。说实话，欣赏诗歌的水平有限，无法真正理解这首诗的意境。但是当读到这首诗时，就感觉这是首写给自己心中永远忘不了的那个人的诗。当你读着这首诗，心里想着就会是他/她。还有一个很重要的原因，周末在家真的无聊（生无可恋脸），打发时间的同时充实下自己博客的内容，随便写写东西。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Web Listener</title>
      <link href="/2019/09/06/Java-Web-Listener/"/>
      <url>/2019/09/06/Java-Web-Listener/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-Java-Web中有三个不同的角色"><a href="#0x01-Java-Web中有三个不同的角色" class="headerlink" title="0x01 Java Web中有三个不同的角色"></a>0x01 Java Web中有三个不同的角色</h2><ul><li><strong>Servlet</strong>是处理用户请求的载体，根据url映射将请求参数发给对应servlet进行数据处理并返回response</li><li><strong>Filter</strong>介于web容器（Tomcat、Jetty等）和Servlet之间，主要是在请求到达servlet之前捕获HttpRequest进行预先处理，比较常见的filter是Login验证、CharacterEncodingFilter</li><li><strong>Listener</strong>独立于Servlet和Filter之外，不存在先后关系。Listener是一种观察者模式，贯穿web应用的整个生命周期。主要作用是定义一系列事件，并对事件进行监听处理</li></ul><h2 id="0x02-8种Listener"><a href="#0x02-8种Listener" class="headerlink" title="0x02 8种Listener"></a>0x02 8种Listener</h2><table><thead><tr><th align="left">Listener</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ServletContextListener</td><td align="left">用于监听ServletContext的启动和销毁</td></tr><tr><td align="left">ServletContextAttributeListener</td><td align="left">用于监听Application范围属性变化</td></tr><tr><td align="left">HttpSessionListener</td><td align="left">用于监听Session的创建和销毁</td></tr><tr><td align="left">HttpSessionIdListener</td><td align="left">用于监听Session的id是否被更改</td></tr><tr><td align="left">HttpSessionAttributeListener</td><td align="left">用于监听session范围属性变化</td></tr><tr><td align="left">HttpSessionActivationListener</td><td align="left">用于监听绑定在HttpSession对象中的JavaBean状态</td></tr><tr><td align="left">HttpSessionBindingListener</td><td align="left">用于监听对象与session的绑定和解绑</td></tr><tr><td align="left">ServletRequestListener</td><td align="left">用于监听ServletRequest对象的初始化和销毁</td></tr><tr><td align="left">ServletRequestAttributeListener</td><td align="left">用于监听ServletRequest对象的属性变化</td></tr></tbody></table><h2 id="0x03-着重看ServletContextListener"><a href="#0x03-着重看ServletContextListener" class="headerlink" title="0x03 着重看ServletContextListener"></a>0x03 着重看ServletContextListener</h2><p>这个Listener的作用是监听ServletContext的启动和销毁，也就是监听web应用的开始和结束。所以通常会使用这个监听器初始化工程和结束工程。<br>这里着重讲两个例子：   </p><blockquote><p>Log4jConfigListener：<br>如果在web.xml设置了这个监听，那么会对日志系统进行初始化，而日志的配置文件路径通过Context-param进行设置   </p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.util.Log4jConfigListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>log4jConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:soc-log4j.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里多说一嘴原理，context-param的设置会形成initParameters（Map&lt;String,String&gt;）存在ServletContext中，Log4jConfigListener读取到配置文件的路径即可进行初始化。初始化使用的是DOMConfigurator的configureAndWatch方法。这里是在web工程中初始化日志配置，web容器（tomcat、jetty等）会加载web.xml进行初始化，进而加载Log4jConfigListener，进而对日志进行初始化。但是在普通Java项目中，没有上述这一系列过程，所以需要自己手动加载log配置文件初始化配置，具体的过程就是使用DOMConfigurator调用configureAndWatch方法。</p><blockquote><p>ContextLoaderListener<br>这个Listener需要和DispatcherServlet一起说明。<br>对于一个Spring项目（非mvc），只需要使用ContextLoaderListener对spring配置进行初始化</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/spring.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主要作用是加载Bean并进行管理。在这个过程中会生成一个WebApplicationContext父容器。    </p><p><strong>总的说来：</strong></p><ul><li>DispatherServlet是Spring mvc工程不可缺少的，Spring MVC配置文件在基础上Spring上有所扩展，所以使用DispatcherServlet对Controller等进行初始化，并根据MVC的初始化过程（初始化文件传输、国际化、映射管理器、异常处理器、视图映射等）。</li><li>DispatherServlet也会生成一个WebApplicationContext，但是此Context是ContextLoaderListener生成的WebApplicationContext的子ApplicationContext。</li><li>两个WebApplicationContext分别加载不同的Spring配置，生成不同的BeanFactory，所以在获取Bean的时候，会先从DispatcherServlet的WebApplicationContext中查找，如果没有再通过父ApplicationContext进行查找。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何打印日志</title>
      <link href="/2019/09/06/%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97/"/>
      <url>/2019/09/06/%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01、日志打印的目的："><a href="#0x01、日志打印的目的：" class="headerlink" title="0x01、日志打印的目的："></a>0x01、日志打印的目的：</h2><blockquote><p>定位错误（问题）发生的时间、位置、原因</p></blockquote><h2 id="0x02、日志打印的时机："><a href="#0x02、日志打印的时机：" class="headerlink" title="0x02、日志打印的时机："></a>0x02、日志打印的时机：</h2><ul><li>调试开发过程中打印调用信息、参数信息</li><li>用户行为信息（埋点）</li><li>程序运行日志（异常情况）</li><li>系统（机器）运行状态</li></ul><h2 id="0x03、日志的内容"><a href="#0x03、日志的内容" class="headerlink" title="0x03、日志的内容"></a>0x03、日志的内容</h2><ul><li>时间</li><li>地点</li><li>级别（debug、info、warn、error、fatal）</li><li>内容（异常情况）</li><li>唯一标识（参数信息，表示导致该条日志发生的参数）</li><li>上下文信息（用于分析异常发生的原因）</li></ul><h2 id="0x04、日志记录"><a href="#0x04、日志记录" class="headerlink" title="0x04、日志记录"></a>0x04、日志记录</h2><blockquote><p>打印日志的地方不要抛出异常，使用日志记录错误信息。</p></blockquote><h2 id="0x05、日志级别"><a href="#0x05、日志级别" class="headerlink" title="0x05、日志级别"></a>0x05、日志级别</h2><ul><li>debug：   最小级别，用于开发调试</li><li>info：    用于输出可参考信息</li><li>warn：    系统出现个别异常情况，但是这种情况可能是因为数据错误等其他情况造成</li><li>error：   系统发生异常（非预期）情况，不会造成系统崩溃，但是需要进行修复，如Null Pointer</li><li>fatal：   系统发生致命错误，造成系统崩溃、退出等情况</li></ul><h2 id="0x06、项目中的思考"><a href="#0x06、项目中的思考" class="headerlink" title="0x06、项目中的思考"></a>0x06、项目中的思考</h2><ul><li>开发调试过程中使用debug级别进行信息输出</li><li>针对方法调用过程中，使用info输出参数或者方法结果进行记录</li><li>第2个方法中一般会造成大量信息输出，日志设置级别一般为warn、error，所以如果设置了warn和error级别，那么在warn和error日志输出中详细记录时间、地点、内容、唯一标示和上下文信息，最好把方法的参数或者过程中产生的重要变量进行输出，以帮助判断错误原因</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2019/09/05/article-title/"/>
      <url>/2019/09/05/article-title/</url>
      
        <content type="html"><![CDATA[<h3 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h3><p>2019年9月5日 于滴滴钻石大厦</p><p>不知道写些什么，因为还不太会用MD。就很尴尬😅！</p><p>对了，明天RNG加油，虽然赢不赢都不太重要了，反正已经进S赛了。</p><p>算了，学学Markdown再写吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/09/05/hello-world/"/>
      <url>/2019/09/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
