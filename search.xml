<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring MVC 一次请求完整过程</title>
      <link href="/2019/09/18/Spring-MVC-%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/09/18/Spring-MVC-%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>一次请求的完整顺序：<br>Filter -&gt; DispatcherServlet -&gt; MapperHandler -&gt; getHandlerMethod -&gt; getHandlerAdapter -&gt; Interceptor.preHandle -&gt; handlerAdapter.handle -&gt; HandlerMethod.invoke -&gt; Interceptor.postHandle -&gt; Interceptor.afterCompletion -&gt; filter</p><p><img src="../../../../images/20190918/1-LoginFilter.png" alt="avatar"></p><p><img src="../../../../images/20190918/2-LoginFilter.png" alt="avatar"></p><p><img src="../../../../images/20190918/3-DispatcherServlet.png" alt="avatar"></p><p><img src="../../../../images/20190918/4-DispatcherServlet.png" alt="avatar"></p><p><img src="../../../../images/20190918/5-DispatcherServlet.png" alt="avatar"></p><p><img src="../../../../images/20190918/6-DispatcherServlet-doDispatch.png" alt="avatar"></p><p><img src="../../../../images/20190918/7-DispatcherServlet-doDispatch.png" alt="avatar"></p><p><img src="../../../../images/20190918/8-DispatcherServlet-doDispatch.png" alt="avatar"></p><p><img src="../../../../images/20190918/9-HandlerExecutionChain-applyPreHandle.png" alt="avatar"></p><p><img src="../../../../images/20190918/10-DispatcherServlet-doDispatch.png" alt="avatar"></p><p><img src="../../../../images/20190918/11-AbstractHandlerMethodAdapter-handle.png" alt="avatar"></p><p><img src="../../../../images/20190918/12-RequestMappingHandlerAdapter-handleInternal.png" alt="avatar"></p><p><img src="../../../../images/20190918/13-RequestMappingHandlerAdapter-invokeHandlerMethod.png" alt="avatar"></p><p><img src="../../../../images/20190918/14-RequestMappingHandlerAdapter-invokeHandlerMethod.png" alt="avatar"></p><p><img src="../../../../images/20190918/15-ServletInvocableHandlerMethod-invokeAndHandle.png" alt="avatar"></p><p><img src="../../../../images/20190918/16-InvocableHandlerMethod-invokeForRequest.png" alt="avatar"></p><p><img src="../../../../images/20190918/17-InvocableHandlerMethod-invokeForRequest.png" alt="avatar"></p><p><img src="../../../../images/20190918/18-InvocableHandlerMethod-doInvoke.png" alt="avatar"></p><p><img src="../../../../images/20190918/19-realMethod.png" alt="avatar"></p><p><img src="../../../../images/20190918/20-DispatcherServlet-doDispatch.png" alt="avatar"></p><p><img src="../../../../images/20190918/21-HandlerExecutionChain-applyPostHandle.png" alt="avatar"></p><p><img src="../../../../images/20190918/22-DispatcherServlet-processDispatchResult.png" alt="avatar"></p><p><img src="../../../../images/20190918/23-HandlerExecutionChain-triggerAfterCompletion.png" alt="avatar"></p><p><img src="../../../../images/20190918/24-LoginFilter.png" alt="avatar"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC项目初始化</title>
      <link href="/2019/09/18/Spring-MVC%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2019/09/18/Spring-MVC%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>我们都知道启动一个<code>Spring MVC</code>项目，需要类似<code>Tomcat</code>的容器支持。<code>Tomcat</code>是一种<code>Servlet</code>容器用于启动<code>Java web</code>项目，而启动一个项目的入口就是<code>web.xml</code>配置文件。在<code>web.xml</code>中主要是为了配置项目中使用的<code>Servlet</code>、<code>Filter</code>和<code>Listener</code>，并对这几种角色进行初始化。这几种角色的作用就不多说了。本文的重点放在项目启动过程，也就是项目初始化。</p><h2 id="0x02-web-xml配置文件"><a href="#0x02-web-xml配置文件" class="headerlink" title="0x02 web.xml配置文件"></a>0x02 web.xml配置文件</h2><p>针对一个<code>Spring MVC</code>项目，需要在<code>web.xml</code>中加载<code>Spring</code>配置文件。初始化的方式有两种：</p><blockquote><p>第一种，使用<code>Listener</code>进行初始化</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:mybatis.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>第二种，使用<code>DispatcherServlet</code>进行初始化</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-web.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于第一种方式，使用<code>ContextLoaderListener</code>监听<code>ServletContext</code>初始化时执行，根据<code>context-param</code>的值读取<code>Spring</code>配置文件进行初始化。关于为什么可以使用<code>Listener</code>进行初始化，可以参考<a href="https://haocdp.github.io/2019/09/06/Java-Web-Listener" target="_blank">Java Web Listener</a>这篇文章。这种方式初始化得到的是<code>Application Context</code>。<br>而第二种方式，是<code>Spring MVC</code>项目更为常见的，因为<code>Spring MVC</code>项目都需要使用<code>DispatcherServlet</code>分发请求。通过<code>init-param</code>加载配置文件进行初始化。这种方式得到的上下文是<code>WebApplicationContext</code>，它是<code>ApplicationContext</code>的子上下文环境。</p><h2 id="0x03-初始化过程"><a href="#0x03-初始化过程" class="headerlink" title="0x03 初始化过程"></a>0x03 初始化过程</h2><p>本文同时使用两种加载配置方式进行初始化，从源代码的层面熟悉整个初始化过程。当然，以我目前的水平只能大致了解一下初始化过程，里面很多详细的过程还没有深究。  </p><p><img src="../../../../images/20190918/init-1.png" alt="avatar"> </p><p><img src="../../../../images/20190918/init-2.png" alt="avatar"> </p><p><img src="../../../../images/20190918/init-3.png" alt="avatar"> </p><p>前面的大致过程是初始化上下文信息，生成<code>ApplicationContext</code>。<br><img src="../../../../images/20190918/init-4.png" alt="avatar"> </p><p>最后来到<code>refresh</code>方法，这里才是初始化重要的位置。顺序来说就是根据配置文件的位置读取到配置文件生成资源文件，然后对这个资源文件进行解析生成<code>BeanFactory</code>。<code>BeanFactory</code>就是对Bean进行管理的地方。默认<code>Bean</code>的<code>Scope</code>都是<code>Singleton</code>，所以初始化得到的都是单例。</p><p>初始化<code>ApplicationContext</code>之后，web容器便会对Filter进行初始化，初始化的过程是调用<code>init</code>方法。最后才是<code>Servlet</code>,同样是调用<code>init</code>方法。（初始化顺序：Listener -&gt; Filter -&gt; Servlet) 所以初始化Filter完成之后，便会对<code>DispatcherServlet</code>进行初始化。由于<code>DispatcherServlet</code>本身并没有<code>init</code>方法，所以会调用父类<code>HttpServletBean</code>的方法。<code>DispatcherServlet</code>是一个多层继承的子类，<code>HttpServletBean</code>不是直接父类。</p><p><img src="../../../../images/20190918/init-5.png" alt="avatar"> </p><p>然后会调用<code>FrameworkServlet</code>的<code>initServletBean</code>方法。</p><p><img src="../../../../images/20190918/init-6.png" alt="avatar"> </p><p>在<code>initServletBean</code>方法中调用<code>initWebApplicationContext</code>方法，从这里开始的初始化过程与上述基本相同，都是读取配置文件生成上下文环境和对应的<code>BeanFactory</code>。</p><p>在加载配置文件的过程中有两个核心类：<br><code>DefaultListableBeanFactory</code> 和 <code>XmlBeanDefinitionReader</code>。</p><h2 id="0x04-Spring配置文件读取"><a href="#0x04-Spring配置文件读取" class="headerlink" title="0x04 Spring配置文件读取"></a>0x04 Spring配置文件读取</h2><p><strong>DefaultListableBeanFactory：Bean加载的核心部分，是多个功能的结合。</strong> </p><hr><p>1、AliasRegistry：定义对alias的简单增删改操作<br>2、SingletonBeanRegistry：定义对单例的注册和获取<br>3、BeanFactory：定义获取bean及其属性<br>4、BeanDefinitionRegistry：定义对BeanDefinition的各种增删改操作<br>5、ConfigurableBeanFactory：提供配置Factory的各种方法<br>6、ListableBeanFactory：根据各种条件获取bean的配置清单<br>7、AutowireCapableBeanFactory：提供创建bean、自动注入、初始化以及应用bean的后处理器<br>DefaultListableBeanFactory是结合上面所有接口功能的实现类，其中也有针对不同功能也有不同的实现类。</p><p><strong>XmlBeanDefinitionReader:针对XML配置文件的读取</strong>  </p><hr><p>1、ResourceLoader：定义资源加载器，主要应用于根据给定的资源文件地址返回对应的Resource<br>2、BeanDefinitionReader：主要定义资源文件读取并转换为BeanDefinition的各个功能<br>3、EnvironmentCapable：定义获取Environment方法<br>4、DocumentLoader：定义从资源文件加载转换为Document的功能<br>5、BeanDefinitionDocumentReader：定义读取Document并注册BeanDefinition功能<br>6、BeanDefinitionParserDelegate：定义解析Element的各种方法  </p><p> <strong>XML配置文件的读取过程：</strong>  </p><hr><p>1、通过实现EnvironmentCapable和BeanDefinitionReader中的方法，使用ResourceLoader将资源文件路径转换为对应的Resource文件<br>2、通过DocumentLoader对Resource文件进行转换，将Resource文件转换为Document文件<br>3、通过实现接口BeanDefinitionDocumentReader的DefaultBeanDefinitionDocumentReader类对Document进行解析，并使用BeanDefinitionParserDelegate对Element进行解析  </p><p>总的来说，这两个核心类，一个是根据配置文件进行解析功能实现，另一个是根据得到的解析结果进行bean的加载、配置、管理功能实现。两个类都是在层层接口定义的基础上，结合不同组件的功能，共同实现最后的目的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你是人间的四月天</title>
      <link href="/2019/09/08/%E4%BD%A0%E6%98%AF%E4%BA%BA%E9%97%B4%E7%9A%84%E5%9B%9B%E6%9C%88%E5%A4%A9/"/>
      <url>/2019/09/08/%E4%BD%A0%E6%98%AF%E4%BA%BA%E9%97%B4%E7%9A%84%E5%9B%9B%E6%9C%88%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<center>我说你是人间的四月天；</center><center>笑响点亮了四面风；轻灵</center><center>在春的光艳中交舞着变。</center><center>&nbsp;</center><center>你是四月早天里的云烟，</center><center>黄昏吹着风的软，星子在</center><center>&nbsp;&nbsp;&nbsp;无意中闪，细雨点洒在花前。</center><center>&nbsp; </center><center>&nbsp;&nbsp;那轻，那娉婷，你是，鲜妍</center><center>百花的冠冕你戴着，你是</center><center>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;天真，庄严，你是夜夜的月圆。</center><center>&nbsp; </center><center>&nbsp;&nbsp;&nbsp;雪化后那片鹅黄，你像；新鲜</center><center>&nbsp;&nbsp;&nbsp;初放芽的绿，你是；柔嫩喜悦</center><center>&nbsp;&nbsp;&nbsp;水光浮动着你梦期待中白莲。</center><center>&nbsp; </center><center>&nbsp;你是一树一树的花开，是燕</center><center>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在梁间呢喃，——你是爱，是暖，</center><center>&nbsp;&nbsp;&nbsp;是希望，你是人间的四月天！</center><center>&nbsp; </center><p>&nbsp;&nbsp;&nbsp;《你是人间的四月天》是林徽因的一本书，也是一首诗。当时买这本书存粹是买书凑单满减，觉得这本书的名字好熟悉，作者又是林徽因就买下了。说实话，我不是一个合格的文艺青年，完全看不了这本书中的散文和诗歌。也就看看里面的书信，但是呢，书信在完全不了解当时的写信缘由和当下情形的情况下，真的很难看懂是什么意思。不是很了解林徽因、梁思成、胡适、徐志摩，无法理解当时作者的写作缘由和心情。所以，只着重看了书中的这首诗。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;这首诗的名字是《你是人间的四月天》，让我想到了一个动漫，《四月是你的谎言》。这个动漫当时看的感觉就是画面很唯美，剧情很清新、纯爱。剧中有句台词是，“没有你的四月又到了”，给我的印象最深，以至于每到四月份都会想到这部动漫。四月真的是春天最好的季节！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;再说回为什么抄录这首诗。说实话，欣赏诗歌的水平有限，无法真正理解这首诗的意境。但是当读到这首诗时，就感觉这是首写给自己心中永远忘不了的那个人的诗。当你读着这首诗，心里想着就会是他/她。还有一个很重要的原因，周末在家真的无聊（生无可恋脸），打发时间的同时充实下自己博客的内容，随便写写东西。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Web Listener</title>
      <link href="/2019/09/06/Java-Web-Listener/"/>
      <url>/2019/09/06/Java-Web-Listener/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-Java-Web中有三个不同的角色"><a href="#0x01-Java-Web中有三个不同的角色" class="headerlink" title="0x01 Java Web中有三个不同的角色"></a>0x01 Java Web中有三个不同的角色</h2><ul><li><strong>Servlet</strong>是处理用户请求的载体，根据url映射将请求参数发给对应servlet进行数据处理并返回response</li><li><strong>Filter</strong>介于web容器（Tomcat、Jetty等）和Servlet之间，主要是在请求到达servlet之前捕获HttpRequest进行预先处理，比较常见的filter是Login验证、CharacterEncodingFilter</li><li><strong>Listener</strong>独立于Servlet和Filter之外，不存在先后关系。Listener是一种观察者模式，贯穿web应用的整个生命周期。主要作用是定义一系列事件，并对事件进行监听处理</li></ul><h2 id="0x02-8种Listener"><a href="#0x02-8种Listener" class="headerlink" title="0x02 8种Listener"></a>0x02 8种Listener</h2><table><thead><tr><th align="left">Listener</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ServletContextListener</td><td align="left">用于监听ServletContext的启动和销毁</td></tr><tr><td align="left">ServletContextAttributeListener</td><td align="left">用于监听Application范围属性变化</td></tr><tr><td align="left">HttpSessionListener</td><td align="left">用于监听Session的创建和销毁</td></tr><tr><td align="left">HttpSessionIdListener</td><td align="left">用于监听Session的id是否被更改</td></tr><tr><td align="left">HttpSessionAttributeListener</td><td align="left">用于监听session范围属性变化</td></tr><tr><td align="left">HttpSessionActivationListener</td><td align="left">用于监听绑定在HttpSession对象中的JavaBean状态</td></tr><tr><td align="left">HttpSessionBindingListener</td><td align="left">用于监听对象与session的绑定和解绑</td></tr><tr><td align="left">ServletRequestListener</td><td align="left">用于监听ServletRequest对象的初始化和销毁</td></tr><tr><td align="left">ServletRequestAttributeListener</td><td align="left">用于监听ServletRequest对象的属性变化</td></tr></tbody></table><h2 id="0x03-着重看ServletContextListener"><a href="#0x03-着重看ServletContextListener" class="headerlink" title="0x03 着重看ServletContextListener"></a>0x03 着重看ServletContextListener</h2><p>这个Listener的作用是监听ServletContext的启动和销毁，也就是监听web应用的开始和结束。所以通常会使用这个监听器初始化工程和结束工程。<br>这里着重讲两个例子：   </p><blockquote><p>Log4jConfigListener：<br>如果在web.xml设置了这个监听，那么会对日志系统进行初始化，而日志的配置文件路径通过Context-param进行设置   </p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.util.Log4jConfigListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>log4jConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:soc-log4j.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里多说一嘴原理，context-param的设置会形成initParameters（Map&lt;String,String&gt;）存在ServletContext中，Log4jConfigListener读取到配置文件的路径即可进行初始化。初始化使用的是DOMConfigurator的configureAndWatch方法。这里是在web工程中初始化日志配置，web容器（tomcat、jetty等）会加载web.xml进行初始化，进而加载Log4jConfigListener，进而对日志进行初始化。但是在普通Java项目中，没有上述这一系列过程，所以需要自己手动加载log配置文件初始化配置，具体的过程就是使用DOMConfigurator调用configureAndWatch方法。</p><blockquote><p>ContextLoaderListener<br>这个Listener需要和DispatcherServlet一起说明。<br>对于一个Spring项目（非mvc），只需要使用ContextLoaderListener对spring配置进行初始化</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/spring.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主要作用是加载Bean并进行管理。在这个过程中会生成一个WebApplicationContext父容器。    </p><p><strong>总的说来：</strong></p><ul><li>DispatherServlet是Spring mvc工程不可缺少的，Spring MVC配置文件在基础上Spring上有所扩展，所以使用DispatcherServlet对Controller等进行初始化，并根据MVC的初始化过程（初始化文件传输、国际化、映射管理器、异常处理器、视图映射等）。</li><li>DispatherServlet也会生成一个WebApplicationContext，但是此Context是ContextLoaderListener生成的WebApplicationContext的子ApplicationContext。</li><li>两个WebApplicationContext分别加载不同的Spring配置，生成不同的BeanFactory，所以在获取Bean的时候，会先从DispatcherServlet的WebApplicationContext中查找，如果没有再通过父ApplicationContext进行查找。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何打印日志</title>
      <link href="/2019/09/06/%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97/"/>
      <url>/2019/09/06/%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01、日志打印的目的："><a href="#0x01、日志打印的目的：" class="headerlink" title="0x01、日志打印的目的："></a>0x01、日志打印的目的：</h2><blockquote><p>定位错误（问题）发生的时间、位置、原因</p></blockquote><h2 id="0x02、日志打印的时机："><a href="#0x02、日志打印的时机：" class="headerlink" title="0x02、日志打印的时机："></a>0x02、日志打印的时机：</h2><ul><li>调试开发过程中打印调用信息、参数信息</li><li>用户行为信息（埋点）</li><li>程序运行日志（异常情况）</li><li>系统（机器）运行状态</li></ul><h2 id="0x03、日志的内容"><a href="#0x03、日志的内容" class="headerlink" title="0x03、日志的内容"></a>0x03、日志的内容</h2><ul><li>时间</li><li>地点</li><li>级别（debug、info、warn、error、fatal）</li><li>内容（异常情况）</li><li>唯一标识（参数信息，表示导致该条日志发生的参数）</li><li>上下文信息（用于分析异常发生的原因）</li></ul><h2 id="0x04、日志记录"><a href="#0x04、日志记录" class="headerlink" title="0x04、日志记录"></a>0x04、日志记录</h2><blockquote><p>打印日志的地方不要抛出异常，使用日志记录错误信息。</p></blockquote><h2 id="0x05、日志级别"><a href="#0x05、日志级别" class="headerlink" title="0x05、日志级别"></a>0x05、日志级别</h2><ul><li>debug：   最小级别，用于开发调试</li><li>info：    用于输出可参考信息</li><li>warn：    系统出现个别异常情况，但是这种情况可能是因为数据错误等其他情况造成</li><li>error：   系统发生异常（非预期）情况，不会造成系统崩溃，但是需要进行修复，如Null Pointer</li><li>fatal：   系统发生致命错误，造成系统崩溃、退出等情况</li></ul><h2 id="0x06、项目中的思考"><a href="#0x06、项目中的思考" class="headerlink" title="0x06、项目中的思考"></a>0x06、项目中的思考</h2><ul><li>开发调试过程中使用debug级别进行信息输出</li><li>针对方法调用过程中，使用info输出参数或者方法结果进行记录</li><li>第2个方法中一般会造成大量信息输出，日志设置级别一般为warn、error，所以如果设置了warn和error级别，那么在warn和error日志输出中详细记录时间、地点、内容、唯一标示和上下文信息，最好把方法的参数或者过程中产生的重要变量进行输出，以帮助判断错误原因</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Log </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2019/09/05/article-title/"/>
      <url>/2019/09/05/article-title/</url>
      
        <content type="html"><![CDATA[<h3 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h3><p>2019年9月5日 于滴滴钻石大厦</p><p>不知道写些什么，因为还不太会用MD。就很尴尬😅！</p><p>对了，明天RNG加油，虽然赢不赢都不太重要了，反正已经进S赛了。</p><p>算了，学学Markdown再写吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/09/05/hello-world/"/>
      <url>/2019/09/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
